#!/usr/bin/env python
# coding: utf-8

#  # Q) 
#  
#  - N개의 수로 이루어진 수열 A1, A2, ..., AN이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다.
# 
# 우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다.
# 
# 예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고, 주어진 연산자가 덧셈(+) 2개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는 총 60가지의 식을 만들 수 있다. 예를 들어, 아래와 같은 식을 만들 수 있다.
# 
# 1+2+3-4×5÷6
# 1÷2+3+4-5×6
# 1+2÷3×4-5+6
# 1÷2×3-4+5+6
# 식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다. 또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 음수를 양수로 나눌 때는 C++14의 기준을 따른다. 즉, 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다. 이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와 같다.
# 
# 1+2+3-4×5÷6 = 1
# 1÷2+3+4-5×6 = 12
# 1+2÷3×4-5+6 = 5
# 1÷2×3-4+5+6 = 7
# N개의 수와 N-1개의 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.
# 
# -> 나눗셈은 정수 나눗셈으로 몫만 취하며, 음수를 양수로 나눌 때는 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다

#  # A) 
#  
#  - 연산자 리스트랑, 수로 이루어진 리스트를 각각 만든다. (수열이라 인덱스를 사용할 수 있는 방법이 있지는 않을까)
#  - 수+연산자 조합을 만들 리스트를 만든다.(DFS 이용) 
#  - 해당 조합으로 연산을 할때 수deque 연산자 deque 순으로 진행한다. 
#  - 수+연산자 조합의 결과를 만들 리스트를 만든다. 
#  - 해당 리스트에서 min, max 값을 추출한다. -> 이거보다 업데이트하면서 추가해주는게 더 빠르다.  
#  

# In[13]:


n =int(input())
num_list = list(map(int,input().split()))
add, sub, mul, div = map(int,input().split())

max_v = -1e9
min_v = 1e9

def DFS(i, arr):
    global add, sub, mul, div, max_v, min_v
    if  i== n: 
        max_v == max(max_v, arr)
        min_v == min(min_v, arr)
        return
    
    else:
        
        if add > 0:
            add -= 1 
            DFS(i + 1, arr + num_list[i])
            add += 1 
        if sub > 0:
            sub -= 1 
            DFS(i + 1, arr - num_list[i])
            sub += 1 
        if mul> 0:
            mul -= 1 
            DFS(i + 1, arr * num_list[i])
            multiply += 1 
        if div>0:
            div -= 1 
            DFS(i + 1, int(arr / num_list[i]))
            div += 1 
        
DFS(1, num_list[0])

print(max_v)
print(max_v)




#연산하는 dfs 백트래킹 .. 만들기 

#해당 결과 리스트에 넣기 
#해당 리스트에서 min max 값 산출 


# In[ ]:





# In[ ]:





# In[ ]:




